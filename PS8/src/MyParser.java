/* Generated By:JavaCC: Do not edit this line. MyParser.java */
    import java.io.PrintStream;
    import java.io.*;
    import java.util.ArrayList;
    import java.lang.reflect.*;

    public class MyParser implements MyParserConstants {

        static ArrayList<DBMS> myDatabases = new ArrayList<DBMS>(); // create empty ArrayList of databases
        static DBMS currentDB = null; // for USE commands

        //public static void main(String[] args)
        public static void mySort(String[] args)
            throws ParseException, TokenMgrError {

            MyParser parser = null;

            if ( args.length < 1  ) {
                        System.out.println("Reading from stdin (exit; to finish)");
                        parser = new MyParser(System.in);
                        parser.Start(System.out);
                } else {
                        try {
                                parser = new MyParser(new DataInputStream(new FileInputStream(args[0])));
                                parser.Start(System.out);
                        } catch (FileNotFoundException e) {
                                System.out.println("File " + args[0] + " not found. Reading from stdin");
                                parser = new MyParser(System.in);
                                parser.Start(System.out);
                        }
                } // else ends here

                //new MyParser(System.in);
            //parser.Start(System.out);
        }

/* Specifying the parser using BNF productions */
/* The input to the parser consists of a single statement so far:
 *     Start --> Statement
 */
  static final public void Start(PrintStream printStream) throws ParseException {
    SelectStatement sStmt;
    CreateTableStatement ctsStmt;
    InsertStatement iStmt;
    UpdateStatement uStmt;
    DBMS newDB;
    DBMS db = new DBMS();
    String requestedDatabaseName;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CREATE:
      case USE:
      case INSERT:
      case UPDATE:
      case SHOW:
      case SELECT:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SHOW:
        jj_consume_token(SHOW);
        jj_consume_token(DATABASES);
        jj_consume_token(SEMICOLON);
                        printStream.print("SHOWING DATABASES: ");
                for (int i = 0; i < myDatabases.size(); i++) {
                        DBMS current = myDatabases.get(i);
                    printStream.print(current.getDbName() + "   ");
                }

                        printStream.println();
                //printStream.print("sql > ");
                printStream.println();
        break;
      case USE:
        requestedDatabaseName = useDatabase(printStream);
                        boolean exists = false;

                        for (int i = 0; i < myDatabases.size(); i++) {
                                if (myDatabases.get(i).getDbName().equals(requestedDatabaseName)) {
                                        currentDB = myDatabases.get(i);
                                        exists = true;
                                        printStream.println("USING DATABASE: " + currentDB.getDbName());
                                        break;
                                }
                        }
                        if (exists == false) {
                                currentDB = null;
                                printStream.println("Error: Database does not exist");
                        }

                        //printStream.print("sql > ");
                        printStream.println();
        break;
      case CREATE:
        jj_consume_token(CREATE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DATABASE:
          newDB = createDatabase(printStream);
                    printStream.println("DATABASE CREATED: " + newDB.getDbName());
                    myDatabases.add(newDB);

                                // FOR TESTING ONLY - TAKE OUT LATER
                    /*for (int i = 0 ; i < myDatabases.size(); i++)
	            {
					DBMS current = myDatabases.get(i);	
	              	printStream.print(current.getDbName());
	            }*/
                    // END

                    //printStream.print("sql> ");
                    printStream.println();
          break;
        case TABLE:
          ctsStmt = buildCreateTableStatement(printStream);
                                printStream.println("RESULT: ");
                                try {
                                        if (currentDB != null)
                                        {
                                        db.createTable(ctsStmt);

                                        Table newTable = new Table();

                                        newTable.setTableName(ctsStmt.getName());

                                        ArrayList<String> attrNames = new ArrayList<String>();
                                        for (int i = 0; i < ctsStmt.getAttrNames().size(); i++) {
                                                        attrNames.add(ctsStmt.getAttrNames().get(i));
                                        }
                                                newTable.setAttrNames(attrNames);

                                                ArrayList<String> attrTypes = new ArrayList<String>();
                                                for (int i = 0; i < ctsStmt.getAttrTypes().size(); i++) {
                                                        attrTypes.add(ctsStmt.getAttrTypes().get(i));
                                                }
                                                newTable.setAttrTypes(attrTypes);

                                        currentDB.getDbTables().add(newTable);


                                        } else {
                                                printStream.println("ERROR: No database currently selected");
                                        }
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }

                                //printStream.print("sql > ");
                                printStream.println();
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case SELECT:
        sStmt = buildSelectStatement(printStream);
            printStream.println("RESULT:");
            db.select(sStmt, currentDB, printStream);

            //printStream.print("sql> ");
            printStream.println();
        break;
      case UPDATE:
        uStmt = buildUpdateStatement(printStream);
                        int index = -1;
                        if (currentDB != null) {
                                // Find index of table that we want to update
                                for (int i = 0; i < currentDB.getDbTables().size(); i++) {
                                        if (currentDB.getDbTables().get(i).getTableName().equals(uStmt.getTableName())) {
                                                index = i;
                                                break;
                                        }
                                }
                                if (index != -1) {
                                        String whereAttrName = uStmt.getWhere().getAttrName();
                                        String whereAttrValue = uStmt.getWhere().getAttrVal();
                                        String setAttrName = uStmt.getSet().getAttrName();
                                        String setAttrValue = uStmt.getSet().getAttrVal();
                                        String tupleAttrValue = "";

                                        Table updateThis = currentDB.getDbTables().get(index);

                                        // If where statement exists, find elements that fulfill the where statement, and update them
                                        if ((uStmt.getWhere().getAttrName() != null) && (uStmt.getWhere().getAttrVal() != null)) {

                                                // Find corresponding attribute value in each tuple and check for equivalence. If equal, update
                                                // for each tuple
                                                for (int i = 0; i < updateThis.getTuples().size(); i++) {
                                                        try {
                                                                Class classToCheck = Class.forName(updateThis.getTableName());
                                                                Object tupleToUpdate = updateThis.getTuples().get(i);
                                                                Method[] methods = classToCheck.getMethods();
                                                                //Method getMethod = methods[attrIndex];
                                                                String getMethodName = "get" + whereAttrName;
                                                                Method getMethod = classToCheck.getMethod(getMethodName);

                                                                try {
                                                                        tupleAttrValue = getMethod.invoke(tupleToUpdate).toString();
                                                                } catch (InvocationTargetException e) {
                                                        System.out.println("22");
                                                        System.out.println(e.getMessage());
                                                    }

                                                                if (whereAttrValue.equals(tupleAttrValue)) {
                                                                        // find name of set method
                                                                        String setMethodName = "set" + setAttrName;

                                                                        // find parameters of set method
                                                                        String getMethodNameToGetParamType = "get" + setAttrName;
                                                                        Method getMethodToGetParamType = classToCheck.getMethod(getMethodNameToGetParamType);
                                                                        Class paramType = getMethodToGetParamType.getReturnType();
                                                                        String paramTypeToString = paramType.toString();

                                                                        Method setMethod = classToCheck.getMethod(setMethodName, paramType);

                                                                        // update tuple
                                                                        if (paramTypeToString.equals("class java.lang.String")) {
                                                                                try {
                                                                                        setMethod.invoke(tupleToUpdate, setAttrValue);
                                                                                }
                                                                        catch (InvocationTargetException e) {
                                                                                System.out.println("22");
                                                                            System.out.println(e.getMessage());
                                                                        }
                                                                        } else if (paramTypeToString.equals("int")) {
                                                                                try {
                                                                                        setMethod.invoke(tupleToUpdate, Integer.parseInt(setAttrValue));
                                                                                }
                                                                        catch (InvocationTargetException e) {
                                                                            System.out.println("22");
                                                                                System.out.println(e.getMessage());
                                                                        }
                                                                        } else if (paramTypeToString.equals("double")) {
                                                                                try {
                                                                                        setMethod.invoke(tupleToUpdate, Double.parseDouble(setAttrValue));
                                                                                }
                                                                    catch (InvocationTargetException e) {
                                                                        System.out.println("22");
                                                                        System.out.println(e.getMessage());
                                                                    }
                                                                        }
                                                                }
                                                        }
                                        catch (SecurityException e1) {
                                                                // TODO Auto-generated catch block
                                                                e1.printStackTrace();
                                                        }
                                                        catch (NoSuchMethodException e1) {
                                                                // TODO Auto-generated catch block
                                                                e1.printStackTrace();
                                                        }
                                                        catch (ClassNotFoundException e) {
                                                    System.out.println("a");
                                                    System.out.println(e.getMessage());
                                                }
                                                catch (IllegalAccessException e) {
                                                    System.out.println("ccc");
                                                    System.out.println(e.getMessage());
                                                }
                                                }
                                        } else { // If no where statement, update all of them.


                                                // update each tuple
                                                for (int i = 0; i < updateThis.getTuples().size(); i++) {
                                                        try {
                                                                Class classToCheck = Class.forName(updateThis.getTableName());
                                                                Object tupleToUpdate = updateThis.getTuples().get(i);
                                                                Method[] methods = classToCheck.getMethods();

                                                                // find name of set method
                                                                String setMethodName = "set" + setAttrName;

                                                                // find parameters of set method
                                                                String getMethodNameToGetParamType = "get" + setAttrName;
                                                                Method getMethodToGetParamType = classToCheck.getMethod(getMethodNameToGetParamType);
                                                                Class paramType = getMethodToGetParamType.getReturnType();
                                                                String paramTypeToString = paramType.toString();

                                                                Method setMethod = classToCheck.getMethod(setMethodName, paramType);

                                                                if (paramTypeToString.equals("class java.lang.String")) {
                                                                        try {
                                                                                setMethod.invoke(tupleToUpdate, setAttrValue);
                                                                        }
                                                            catch (InvocationTargetException e) {
                                                                System.out.println("22");
                                                                System.out.println(e.getMessage());
                                                            }
                                                                } else if (paramTypeToString.equals("int")) {
                                                                        try {
                                                                                setMethod.invoke(tupleToUpdate, Integer.parseInt(setAttrValue));
                                                                        }
                                                            catch (InvocationTargetException e) {
                                                                System.out.println("22");
                                                                System.out.println(e.getMessage());
                                                            }
                                                                } else if (paramTypeToString.equals("double")) {
                                                                        try {
                                                                                setMethod.invoke(tupleToUpdate, Double.parseDouble(setAttrValue));
                                                                        }
                                                            catch (InvocationTargetException e) {
                                                                System.out.println("22");
                                                                System.out.println(e.getMessage());
                                                            }
                                                                }
                                                        }
                                                        catch (ClassNotFoundException e) {
                                                    System.out.println("a");
                                                    System.out.println(e.getMessage());
                                                }
                                                catch (IllegalAccessException e) {
                                                    System.out.println("ccc");
                                                    System.out.println(e.getMessage());
                                                }
                                                catch (SecurityException e1) {
                                                                // TODO Auto-generated catch block
                                                                e1.printStackTrace();
                                                        } catch (NoSuchMethodException e1) {
                                                                // TODO Auto-generated catch block
                                                                e1.printStackTrace();
                                                        }
                                        }
                                        }
                                } else {
                                        printStream.println("ERROR: Table does not exist");
                                }
                        } else {
                                printStream.println("ERROR: No database currently in use");
                        }
                        //printStream.print("sql > ");
                        printStream.println();
        break;
      case INSERT:
        iStmt = buildInsertStatement(printStream);
                        int index2 = -1;
                        if (currentDB != null) {
                                // Find index of table that we want to insert the new element into
                                for (int i = 0; i < currentDB.getDbTables().size(); i++) {
                                        if (currentDB.getDbTables().get(i).getTableName().equals(iStmt.getTableName())) {
                                                index2 = i;
                                                break;
                                        }
                                }

                                // Insert the new element into appropriate table
                                if (index2 != -1) {
                                        ArrayList<Table> tables = currentDB.getDbTables();
                                        Table tableToBeInsertedInto = tables.get(index2);

                                        // Create new object to be inserted
                                        try {
                                                Class classToInsert = Class.forName(iStmt.getTableName());
                                                Object insertThis = classToInsert.newInstance();

                                                String setMethodName = "";
                                                Method setMethod = null;
                                                String getMethodName = "";
                                                Method getMethod = null;
                                                Class paramType = null;

                                                // set attributes
                                                for (int i = 0; i < iStmt.getAttributes().size(); i++) {
                                                                String parameter = iStmt.getAttributes().get(i);

                                                                // get name of set method
                                                                setMethodName = "set" + tableToBeInsertedInto.getAttrNames().get(i);

                                                                // get param type of set method
                                                                getMethodName = "get" + tableToBeInsertedInto.getAttrNames().get(i);
                                                                getMethod = classToInsert.getMethod(getMethodName);
                                                                paramType = getMethod.getReturnType();
                                                                String paramTypeToString = paramType.toString();

                                                                setMethod = classToInsert.getMethod(setMethodName, paramType);

                                                                if (paramTypeToString.equals("class java.lang.String")) {
                                                                        try {
                                                                                setMethod.invoke(insertThis, parameter);
                                                                        }
                                                            catch (InvocationTargetException e) {
                                                                System.out.println("22");
                                                                System.out.println(e.getMessage());
                                                            }
                                                                } else if (paramTypeToString.equals("int")) {
                                                                        try {
                                                                                setMethod.invoke(insertThis, Integer.parseInt(parameter));
                                                                        }
                                                            catch (InvocationTargetException e) {
                                                                System.out.println("22");
                                                                System.out.println(e.getMessage());
                                                            }
                                                                } else if (paramTypeToString.equals("double")) {
                                                                        try {
                                                                                setMethod.invoke(insertThis, Double.parseDouble(parameter));
                                                                        }
                                                            catch (InvocationTargetException e) {
                                                                System.out.println("22");
                                                                System.out.println(e.getMessage());
                                                            }
                                                                }
                                                }


                                                tableToBeInsertedInto.addTuple(insertThis); // insert this new element

                                                printStream.print("VALUES: (");
                                                for (int i = 0; i < iStmt.attributes.size(); i++) {
                                                        printStream.print(iStmt.attributes.get(i) + " ");
                                                }
                                                printStream.print(")");
                                                printStream.println(" INSERTED INTO TO " + iStmt.tableName + " TABLE");

                                        }
                                catch (ClassNotFoundException e) {
                                    System.out.println("a");
                                    System.out.println(e.getMessage());
                                }
                                catch (InstantiationException e) {
                                    System.out.println("bb");
                                    System.out.println(e.getMessage());
                                }
                                catch (IllegalAccessException e) {
                                    System.out.println("ccc");
                                    System.out.println(e.getMessage());
                                }
                                catch (SecurityException e1) {
                                                // TODO Auto-generated catch block
                                                e1.printStackTrace();
                                        }
                                        catch (NoSuchMethodException e1) {
                                                // TODO Auto-generated catch block
                                                e1.printStackTrace();
                                        }
                                } else {
                                        printStream.println("ERROR: Table does not exist");
                                }
                        }
                        //printStream.print("sql > ");
                        printStream.println();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(EXIT);
    jj_consume_token(SEMICOLON);
      printStream.println("EXIT. Good Bye...");
  }

  static final public String useDatabase(PrintStream printStream) throws ParseException {
        String name;
        Token t;
    t = jj_consume_token(USE);
    t = jj_consume_token(DATABASE);
    t = jj_consume_token(STRING);
          name = t.image;
    t = jj_consume_token(SEMICOLON);
          {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  static final public EqualExpression buildEqualExpression(PrintStream printStream) throws ParseException, NumberFormatException {
    Token t;
    EqualExpression eq = new EqualExpression();
    t = jj_consume_token(STRING);
          eq.attr = t.image;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUAL:
      t = jj_consume_token(EQUAL);
        eq.op = t.image;
      break;
    case GREATERTHAN:
      t = jj_consume_token(GREATERTHAN);
        eq.op = t.image;
      break;
    case LESSTHAN:
      t = jj_consume_token(LESSTHAN);
        eq.op = t.image;
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIGITS:
      t = jj_consume_token(DIGITS);
          eq.val = t.image;
      break;
    case STRING:
      t = jj_consume_token(STRING);
          eq.attr2 = t.image;
      break;
    case QUOTE:
      t = jj_consume_token(QUOTE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        t = jj_consume_token(STRING);
                          eq.val = (t.image);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STRING:
            ;
            break;
          default:
            jj_la1[4] = jj_gen;
            break label_2;
          }
          t = jj_consume_token(STRING);
                                  eq.val = eq.val.concat(t.image);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AND:
          case DASH:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case DASH:
              t = jj_consume_token(DASH);
                                    eq.val = eq.val.concat(t.image);
              break;
            case AND:
              t = jj_consume_token(AND);
                                    eq.val = eq.val.concat(t.image);
              break;
            default:
              jj_la1[5] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          default:
            jj_la1[6] = jj_gen;
            ;
          }
        }
        t = jj_consume_token(QUOTE);
        break;
      case DIGITS:
        t = jj_consume_token(DIGITS);
                          eq.val = eq.val.concat(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DASH:
          t = jj_consume_token(DASH);
                            eq.val = eq.val.concat(t.image);
          t = jj_consume_token(DIGITS);
                            eq.val = eq.val.concat(t.image);
          break;
        default:
          jj_la1[7] = jj_gen;
          ;
        }
        t = jj_consume_token(QUOTE);
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case DOUBLE:
      t = jj_consume_token(DOUBLE);
                  eq.val = t.image;
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return eq;}
    throw new Error("Missing return statement in function");
  }

  static final public DBMS createDatabase(PrintStream printStream) throws ParseException {
        Token t;
        DBMS newDB;
    //t = <CREATE>
        //{ buffer.append(t.image); }
    
        t = jj_consume_token(DATABASE);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(STRING);
      newDB = new DBMS(t.image);
    t = jj_consume_token(SEMICOLON);
      printStream.println();
      {if (true) return newDB;}
    throw new Error("Missing return statement in function");
  }

  static final public InsertStatement buildInsertStatement(PrintStream printStream) throws ParseException {
        Token t;
        InsertStatement iStmt = new InsertStatement();
    t = jj_consume_token(INSERT);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(INTO);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(STRING);
      iStmt.tableName = t.image;
    t = jj_consume_token(VALUES);
    //{ buffer.append(t.image); }	
    
        t = jj_consume_token(PARENTHESES);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTE:
        t = jj_consume_token(QUOTE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          t = jj_consume_token(STRING);
                                  iStmt.attributes.add(t.image);
                                  String updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1);
          label_4:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case STRING:
              ;
              break;
            default:
              jj_la1[10] = jj_gen;
              break label_4;
            }
            t = jj_consume_token(STRING);
                                          updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1).concat(t.image);
                                          iStmt.attributes.set(iStmt.attributes.size() - 1, updatedAttr);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case AND:
            case DASH:
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case DASH:
                t = jj_consume_token(DASH);
                                                  updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1).concat(t.image);
                                                  iStmt.attributes.set(iStmt.attributes.size() - 1, updatedAttr);
                break;
              case AND:
                t = jj_consume_token(AND);
                                                  updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1).concat(t.image);
                                                  iStmt.attributes.set(iStmt.attributes.size() - 1, updatedAttr);
                break;
              default:
                jj_la1[11] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
            default:
              jj_la1[12] = jj_gen;
              ;
            }
          }
          t = jj_consume_token(QUOTE);
          break;
        case DIGITS:
          t = jj_consume_token(DIGITS);
                                  iStmt.attributes.add(t.image);
                                  updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DASH:
            t = jj_consume_token(DASH);
                                    updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1).concat(t.image);
                                    iStmt.attributes.set(iStmt.attributes.size() - 1, updatedAttr);
            t = jj_consume_token(DIGITS);
                                    updatedAttr = iStmt.attributes.get(iStmt.attributes.size() - 1).concat(t.image);
                                    iStmt.attributes.set(iStmt.attributes.size() - 1, updatedAttr);
            break;
          default:
            jj_la1[13] = jj_gen;
            ;
          }
          t = jj_consume_token(QUOTE);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case DIGITS:
        t = jj_consume_token(DIGITS);
                          iStmt.attributes.add(t.image);
        break;
      case DOUBLE:
        t = jj_consume_token(DOUBLE);
                          iStmt.attributes.add(t.image);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGITS:
      case DOUBLE:
      case QUOTE:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_3;
      }
    }
    // repeat as many times as you want
    
        t = jj_consume_token(PARENTHESES);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(SEMICOLON);
      printStream.println();
      {if (true) return iStmt;}
    throw new Error("Missing return statement in function");
  }

  static final public CreateTableStatement buildCreateTableStatement(PrintStream printStream) throws ParseException {
        Token t;
        CreateTableStatement cts = new CreateTableStatement();
    //t = <CREATE>
        //{ buffer.append(t.image); }
    
        t = jj_consume_token(TABLE);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(STRING);
      cts.name = t.image;
    t = jj_consume_token(PARENTHESES);
    label_5:
    while (true) {
      t = jj_consume_token(STRING);
                  cts.attrNames.add(t.image);
      t = jj_consume_token(TYPE);
                  cts.attrTypes.add(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_5;
      }
    }
    // repeat as many times as you want
    
        t = jj_consume_token(PARENTHESES);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(SEMICOLON);
      printStream.println();
      {if (true) return cts;}
    throw new Error("Missing return statement in function");
  }

  static final public UpdateStatement buildUpdateStatement(PrintStream printStream) throws ParseException {
        Token t;
        UpdateStatement uStmt = new UpdateStatement();
    t = jj_consume_token(UPDATE);
    //{ buffer.append(t.image); }
    
        t = jj_consume_token(STRING);
      uStmt.tableName = t.image;
    t = jj_consume_token(SET);
    //{ buffer.append(t.image); }
    
            uStmt.set = buildEqualExpression(printStream);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      t = jj_consume_token(WHERE);
      //{ buffer.append(t.image); }
      
              uStmt.where = buildEqualExpression(printStream);
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    // optional WHERE statement
    
        t = jj_consume_token(SEMICOLON);
      printStream.println(uStmt.tableName + " tuple(s) updated");
      {if (true) return uStmt;}
    throw new Error("Missing return statement in function");
  }

  static final public SelectStatement buildSelectStatement(PrintStream printStream) throws ParseException {
    Token t;
    SelectStatement ss = new SelectStatement();
    t = jj_consume_token(SELECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STAR:
      t = jj_consume_token(STAR);
              ss.select.add(t.image);
      break;
    case STRING:
      label_6:
      while (true) {
        t = jj_consume_token(STRING);
              ss.select.add(t.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_6;
        }
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(FROM);
    label_7:
    while (true) {
      t = jj_consume_token(STRING);
        ss.from.add(t.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_7;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHERE:
      t = jj_consume_token(WHERE);
                          ss.where.add(buildEqualExpression(printStream));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        t = jj_consume_token(AND);
                                  ss.where.add(buildEqualExpression(printStream));
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    // optional WHERE statement
    
        t = jj_consume_token(SEMICOLON);
      printStream.println();
      {if (true) return ss;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public MyParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[24];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x114940,0x280,0x114940,0xe000000,0x0,0x800000,0x800000,0x0,0x20000000,0x60000000,0x0,0x800000,0x800000,0x0,0x20000000,0x60000000,0x60000000,0x0,0x400000,0x0,0x80000,0x0,0x800000,0x400000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x2,0x4,0x4,0x4,0x2,0x3,0x2,0x4,0x4,0x4,0x2,0x1,0x1,0x2,0x0,0x2,0x2,0x2,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public MyParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MyParser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MyParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MyParser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MyParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MyParser(MyParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MyParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[36];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 24; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 36; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

    }
